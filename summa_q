import Mathlib

open BigOperators Filter Finset Nat Set

variable (n m : ℕ) (w u : ℤ) (p q : ℚ) (x y z : ℝ) (a b : α) (X Y Yhat f f1 f2 : ℕ → ℚ)

-------------------------------------------------------------------
/- ### Testing Functions ### -/
-- ID Function : Spits back the same number
def id_func := (n : ℚ)

-- AddOne Function : Adds one to the number
def add_one := (n + 1 : ℚ)

-- TestList : Example of a list of rational numbers
def test_list
  | 0 => (15 / 4 : ℚ)
  | 1 => (13 / 4)
  | 2 => (11 / 4)
  | 3 => (9 / 4)
  | 4 => (23 / 10)
  | _ => 0

-------------------------------------------------------------------
/- ### Stat Functions ### -/
def mean := (1 / n : ℚ) * ∑ i in range n, Y i
#eval mean 8 (fun (x:ℕ) => x^2)

def SSE := ∑ i in range n, (Y i - Yhat i) ^ 2
#eval SSE 5 (fun _ => 1) (fun x => factorial x)
#eval SSE 4 test_list (fun _ => mean 4 test_list)

def MSE := (1 / n : ℚ) * SSE n Y Yhat
#eval MSE 5 test_list add_one

-------------------------------------------------------------------
/- ### Proofs ### -/

theorem self_func_sse : SSE n f f = 0 := by
  have h : 2 ≠ 0 := by simp only [ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true]
  simp_rw [SSE, sub_self, zero_pow h, sum_const_zero]

theorem self_func_mse : MSE n f f = 0 := by rw [MSE, self_func_sse, mul_zero]

theorem sum_deviations_sub_mean_zero (hn : 0 < (n:ℚ)) : ∑ i in range n, (Y i - mean n Y) = 0 := by
  rw [sum_sub_distrib, sum_const, card_range, nsmul_eq_mul, mean, mul_sum, mul_sum, sub_eq_add_neg,
    ← neg_one_mul, mul_sum, ← sum_add_distrib, show 0 = ∑ i in range n, (0 : ℚ) by
    rw [sum_const_zero]]
  congr with x
  ring_nf!
  field_simp

theorem sse_rw_yhat_cons (h : ∀ i, Yhat i = p) : SSE n Y Yhat = ∑ i in range n, (Y i - mean n Y) ^
  2 + 2 * (mean n Y - p) * ∑ i in range n, (Y i - mean n Y) + n * (mean n Y - p) ^ 2 := by
    rw [show n * (mean n Y - p) ^ 2 = ∑ i in range n, (mean n Y - p) ^ 2 by simp only [sum_const,
      card_range, nsmul_eq_mul], mul_sum, add_comm, ← sum_add_distrib, ← sum_add_distrib, SSE]
    congr with x
    rw [show Y x - Yhat x = (Y x - mean n Y) + (mean n Y - Yhat x) by rw [sub_add_sub_cancel], h]
    ring

theorem sse_rw_yhat_cons' : SSE n Y (fun _ => p) = ∑ i in range n, (Y i - mean n Y) ^
  2 + 2 * (mean n Y - p) * ∑ i in range n, (Y i - mean n Y) + n * (mean n Y - p) ^ 2 := by
    rw [show n * (mean n Y - p) ^ 2 = ∑ i in range n, (mean n Y - p) ^ 2 by simp only [sum_const,
      card_range, nsmul_eq_mul], mul_sum, add_comm, ← sum_add_distrib, ← sum_add_distrib, SSE]
    congr with x
    rw [show Y x - p = (Y x - mean n Y) + (mean n Y - p) by rw [sub_add_sub_cancel]]
    ring

theorem min_sse_const_yhat_mean (hy : ∀ i, Yhat i = mean n Y) (hf : ∀ i, f i = fm)
  (hn : 0 < (n : ℚ)) (h : mean n Y ≠ fm) : SSE n Y Yhat < SSE n Y f := by
    rw [sse_rw_yhat_cons n (mean n Y) Y Yhat hy, sse_rw_yhat_cons n fm Y f hf, sub_self,
      zero_pow (by simp only [ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true])]
    simp only [mul_zero, zero_mul, add_zero]
    rw [add_assoc, lt_add_iff_pos_right, sum_deviations_sub_mean_zero n Y hn, mul_zero, zero_add]
    exact Rat.instLinearOrderedCommRing.proof_3 n ((mean n Y - fm) ^ 2) hn (sq_pos_of_ne_zero
      (mean n Y - fm) (sub_ne_zero_of_ne h))

theorem min_sse_const_yhat_mean' (h : mean n Y ≠ fm) (hn : 0 < (n:ℚ)) :  SSE n Y
  (fun _ => mean n Y) < SSE n Y (fun _ => fm) := by
    simp only [sse_rw_yhat_cons', sub_self, mul_zero]
    rw [zero_pow (by positivity), zero_mul, add_zero, mul_zero, add_zero, add_assoc,
      lt_add_iff_pos_right, sum_deviations_sub_mean_zero n Y hn, mul_zero, zero_add]
    exact Rat.instLinearOrderedCommRing.proof_3 n ((mean n Y - fm) ^ 2) hn (sq_pos_of_ne_zero
      (mean n Y - fm) (sub_ne_zero_of_ne h))

-------------------------------------------------------------------
/- ### Testing Grounds ### -/

example : SSE 4 test_list (fun _ => mean 4 test_list) < SSE 4 test_list (fun _ => 1) := by
  have h : mean 4 test_list = 3 := by rfl
  have h' : mean 4 test_list ≠ 1 := by {rw [h]; linarith}
  have h'' : 0 < (4:ℚ) := by linarith
  exact min_sse_const_yhat_mean' 4 test_list h' h''
#eval SSE 4 test_list (fun _ => mean 4 test_list)
#eval SSE 4 test_list (fun _ => 1)
